## 冒泡排序Bubble Sort

- 重点是内层循环的截止条件

``` javascript
nums = [3, 2, 1, 6, 0, 5];
// bubble sort
// 一轮确定一个数据，所以要n轮，
// 如果交换次数为0，说明有序，跳出循环
let exchange = 0, temp = 0;
for (let i = 1; i <= nums.length; i++) {
    exchange = 0;
    for (j = 0; j < nums.length - i; j++) {
        if (nums[j] > nums[j + 1]) {
            temp = nums[j];
            nums[j] = nums[j + 1];
            nums[j + 1] = temp;
            exchange++;
        }
    }
    // 一轮过后，若没有数据交换，说明有序，直接跳出循环
    if (exchange == 0) break;
}
console.log(nums);
```

## 插入排序Insertation Sort

- 重点是已排序区间和未排序区间的理解。外层循环就是取未排序区间的每个数，里层循环就是遍历已排序区间，找到合适的插入位置

``` javascript
// 插入排序,
// 取未排序区间的一个元素
for (let j = 1; j < nums.length; j++) {
    // 从已排序区间的尾部开始比较，不满足要求就后移一位，注意不能使用nums[j]，因为后面会改变
    let unorder = nums[j];
    for (let i = j - 1; i >= 0; i--) {
        // 小于，后移已排序区间
        if (unorder < nums[i]) {
            nums[i + 1] = nums[i];
        }
        if (unorder >= nums[i]) {
            nums[i + 1] = unorder;
            break;
        }
        // 插入头结点，如果该数比头结点大的话，在上一步应该就会被插入数组，跳出循环。
        if (i == 0) {
            nums[i] = unorder;
        }
    }
}
```

## 归并排序

- 后序遍历

``` javascript
var sortArray = function(nums) {
// mergeSort
function mergeSort(nums, low, high) {
    // 只有一个元素，不需要merge
    if (low >= high) return;

    let middle = parseInt((low + high) / 2);
    //以中间为分界点，将左右两个子数组排序 
    mergeSort(nums, low, middle);
    mergeSort(nums, middle + 1, high);

    // 子数组排好序后，merge在一起
    let temp = new Array();
    // 两个指针指向子数组中最小的数
    let i = low, j = middle + 1;

    while (i <= middle && j <= high) {
        if (nums[i] < nums[j]) {
            temp[temp.length] = nums[i];
            i++;
        } else {
            temp[temp.length] = nums[j];
            j++;
        }
    }
    // 可能有一个子数组没有遍历完
    while (i <= middle) {
        temp[temp.length] = nums[i];
        i++;
    }
    while (j <= high) {
        temp[temp.length] = nums[j];
        j++;
    }
    
    //将temp[0,n]数组给nums[low,high]数组的对应位置
    let index = 0;
    for (let k = low; k <= high; k++) {
        nums[k] = temp[index++];
    }

}
mergeSort(nums, 0, nums.length - 1);
return nums;
};
```

## 快速排序

- 重点是：`每次确定分界点的确切位置`。

### 法一

- 注意`递归的终止条件`
- 

``` javascript
var sortArray = function(nums) {
    // quick sort
    // 先序遍历
function quick_sort(nums, low, high) {
    //递归的终止条件，只有一个数，不需要排序
    if (low >= high) return;
    let left = low, right = high;
    // 取分界点。
    temp = nums[left];
    while (low < high) {
        while (nums[high] >= temp && low < high) high--;
        nums[low] = nums[high];
        while (nums[low] < temp && low < high) low++;
        nums[high] = nums[low];
    }
    nums[low] = temp;
    // 递归排序以分界点为界限的左右数组, low = high时跳出
    quick_sort(nums, left, low-1);
    quick_sort(nums, low + 1, right);

}
    quick_sort(nums, 0, nums.length - 1);
    return nums;
};
```

- 法二
- i记录已排好序的区间。j代表未排好序的空间，

``` javascript
function swap(nums, i, j) {
    let exchange = nums[i];
    nums[i] = nums[j];
    nums[j] = exchange;
}
function quick_sort(nums, low, high) {
    if (low >= high) return;
    // 分界点取最后一个
    let i = low, pivot = nums[high];
    // j从一开始到，分界点的 前一个
    for (let j = low; j < high; j++) {
        if (nums[j] < pivot) {
            swap(nums, i, j);
            i++;
        }
    }
    // i就是分界点插入的位置
    swap(nums, i, high);
    // 分界点已经确认好位置，无需参与
    quick_sort(nums, low, i - 1);
    quick_sort(nums, i + 1, high);
}
quick_sort(nums, 0, nums.length - 1);
```

