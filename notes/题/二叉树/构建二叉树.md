## [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

- 对于根节点来说，需要找到`当前数组中最大的那个数作为根节点的值`，然后最大值左边的为左子树，最大值右边的为右子树。递归调用函数，对左右子树进行构建。
- `左右子树需要各自找到左边或右边数组的最大值`，所以参数`肯定是要有left和right`来确定子树根节点值的。然后对各自的左右子树进行构建

``` javascript
var constructMaximumBinaryTree = function(nums) {
    function getMaxIndex(nums,left,right){
        let max = 0, maxIndex = left;
        for(let i = left; i <= right; i++){
            if(nums[i] > max){
                max = nums[i], maxIndex = i;
            } 
        }
        return [max, maxIndex];
    }
    function getTree(nums, left, right){
        if(left > right) return null;
        let [rootVal, rootIndex] = getMaxIndex(nums, left, right);
        let root = new TreeNode();
        root.val = rootVal;
        
        root.left = getTree(nums,left, rootIndex - 1);
        root.right = getTree(nums, rootIndex + 1, right);

        return root;
    }
    return getTree(nums, 0, nums.length - 1);
};
```

## [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

``` bash
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]

```

输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

- 通过`前序遍历数组，我们可以很容易得到根节点的值`，就是`preorder[preLeft]`，当前树在前序遍历数组范围的第一个数。
- 通过`中序遍历数组`，我们可以通过得到的根节点的值确定其在中序遍历数组的位置，然后就可以得到`左子树的节点数`(因为在前序遍历数组中，左子树根节点的位置就是preLeft+1，所以通过左子树的节点树，我们能得到左子树的结束位置和右子树的开始位置)。
- 于是我们可以将`递归调用函数`，`构建左右子树`，`输入参数就是前序遍历数组子树所在的范围`。但同时每一次我们都需要用到中序遍历数组中子树所在的范围来在前序遍历数组中确认左右子树所在范围。因此输入参数还得加上`中序遍历数组中子树所在范围`。
- **`同时不要忘记超出边界时，即越过叶子节点时，返回null`**

``` javascript
var buildTree = function(preorder, inorder) {
    function getInorderIndex(rootVal, inorder, inLeft, inRight){
        for(let i = inLeft; i <= inRight; i++){
            if(inorder[i] == rootVal) return i;
        }
    }
    function buildBinaryTree(preorder, preLeft, preRight, inorder, inLeft, inRight){
        // 如果preLeft > preRight，那么一定有inLeft > inRight
        if(preLeft > preRight || inLeft > inRight) return null;
        // 拿到根节点的值
        let rootVal = preorder[preLeft];
        // 找到根节点在中序遍历数组中的位置，这个位置一定是在构造子树的中序数组范围内
        let rootInorderIndex = getInorderIndex(rootVal, inorder, inLeft, inRight);
        // 通过根节点在中序遍历数组中的位置，和子树的中序数组范围可以得到节点的左子树数量
        let leftSonCount = rootInorderIndex - inLeft;
        // 从而可以得到root的左右子树在前序遍历数组中的范围
        // 构建左子树
        let leftSon = buildBinaryTree(preorder, preLeft + 1, preLeft + leftSonCount, inorder, inLeft, rootInorderIndex - 1);
        let rightSon = buildBinaryTree(preorder, preLeft + leftSonCount + 1, preRight, inorder, rootInorderIndex + 1, inRight);
        let node = new TreeNode(rootVal, leftSon, rightSon);
        return node;
    }
    let root = buildBinaryTree(preorder, 0 ,preorder.length - 1, inorder, 0, inorder.length - 1);
    return root;
};
```

