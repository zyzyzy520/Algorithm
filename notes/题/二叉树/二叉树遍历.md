# 二叉树遍历

**`无论是前、中、后序遍历，都是先访问根节点，再访问它的左子树，再访问它的右子树`**。

**`前、中、后序遍历都是基于DFS，唯一区别是：在什么时间点去处理节点`**

## [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

### 法一：递归

比较简单，直接上代码

``` javascript
var preorderTraversal = function(root) {
     let ans = [];
     function dfs(node){
         if(node == null) return;
         ans.push(node.val);
         dfs(node.left);
         dfs(node.right);
     }
     dfs(root);
     return ans;
};
```

### 法二：迭代

- 首先要用栈模拟出DFS递归遍历树的过程
  1. 先`从根节点 开始不断地将左节点压入栈`
  2. 访问**`已入栈的节点的右子树了`**。并且是先访问**`『位于树的底部的』`**即**`『位于栈的顶部的』`**节点的右子树。
  3. 让栈顶节点出栈，出栈的同时，判断其右子节点是否为空，不为空的话，就重复(1)。从右子节点开始，不断将右子节点的左节点入栈
- 前序遍历，**`在栈顶节点的左子节点被访问之前`**，操作该节点。因此在不断将左节点压入栈的前面，操作该节点

``` javascript
var preorderTraversal = function(root) {
    let stack = [], ans = [];
    pushLeftBranch(root, stack, ans);
    while(stack.length != 0){
        // 拿出栈顶元素
        let node = stack.pop();

        //判断栈顶节点是否有右节点，有右节点，要将右节点和右节点的左子树压入
        if(node.right != null) pushLeftBranch(node.right, stack, ans);
    }
    function pushLeftBranch(node, stack, ans){
        while(node != null){
            ans.push(node.val);  //前序遍历代码
            stack.push(node);
            node = node.left;
        }
    }
    return ans;
};
```

## **[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)**

### 法一：递归

``` javascript
var inorderTraversal = function(root) {
     let ans = [];
     function dfs(node){
         if(node == null) return;
         dfs(node.left);
         ans.push(node.val);
         dfs(node.right);
     }
     dfs(root);
     return ans
};
```

### 法二：迭代

- 首先要用栈模拟出DFS递归遍历树的过程
  1. 先`从根节点 开始不断地将左节点压入栈`
  2. 访问**`已入栈的节点的右子树了`**。并且是先访问**`『位于树的底部的』`**即**`『位于栈的顶部的』`**节点的右子树。
  3. 让栈顶节点出栈，出栈的同时，判断其右子节点是否为空，不为空的话，就重复(1)。从右子节点开始，不断将右子节点的左节点入栈
- 中序序遍历，**`在栈顶节点的左子节点被操作后，右子树被操作前`**，操作该节点。因此在访问右节点之前，对节点进行操作

``` javascript
var inorderTraversal = function(root) { 
    let stack = [], ans=[];
    pushLeftBranch(root, stack);
    while(stack.length != 0){
        let node = stack.pop();
        // 中序遍历代码
        ans.push(node.val);
        // 压入该节点的右子节点的左子树
        if(node.right != null) pushLeftBranch(node.right, stack)
    }
    function pushLeftBranch(node,  stack){
        while(node != null){
            stack.push(node);
            node = node.left;
        }
    }
    return ans;
};
```

## [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)★

### 法一：递归

``` javascript
var postorderTraversal = function(root) {
     let ans = [];
     function dfs(node){
         if(node == null) return;
         dfs(node.left);
         dfs(node.right);
         ans.push(node.val);
     }
     dfs(root);
     return ans;
};
```

### 法二：迭代

- 首先要用栈模拟出DFS递归遍历树的过程
  1. 先`从根节点 开始不断地将左节点压入栈`
  2. 访问**`已入栈的节点的右子树了`**。并且是先访问**`『位于树的底部的』`**即**`『位于栈的顶部的』`**节点的右子树。
  3. 让栈顶节点出栈，出栈的同时，判断其右子节点是否为空，不为空的话，就重复(1)。从右子节点开始，不断将右子节点的左节点入栈
- 后序遍历，**`在栈顶节点的左子树和右子树均被访问后`**，操作该节点。因此要进行一些修改
- 不能`let node = stack.pop();`因为此时节点的右子树还未被访问，弹出栈后，就再也拿不到该节点了，但同时我们也想通过该节点找到其右子树，所以`let node = stack[stack.length - 1];`
- 同时新增一个visited哈希表，用于记录`已经访问过的节点`(`值被加入ans数组`中)。
- 如果`栈顶结点是叶子结点或者左右子树都已被访问`，那么**`操作该节点，并从栈中弹出该节点，将该节点添加到hash表中`**。
- 而我们在**`一开始就向visited数组中添加null`**，就可以使得叶子节点和左右子树的判断都可以被统一。因为对于叶子节点来说，它的左右子树是null，初始化就添加，代表着肯定被访问.

``` javascript
var postorderTraversal = function(root) {

    let stack = [], hash = new Set(), ans=[];
    hash.add(null); //重要
    pushLeftBranch(root, stack, hash);
    while(stack.length != 0){
        let node = stack[stack.length - 1];
        if(hash.has(node.left) && hash.has(node.right)){
            // 后序遍历代码
            ans.push(node.val);
            stack.pop();
            hash.add(node);  // 重要
        }else if(node.right != null) pushLeftBranch(node.right, stack, hash);

    }
    function pushLeftBranch(node, stack, hash){
        while(node != null){
            stack.push(node);
            node = node.left;
        }
    }
    return ans;
};
```

