## [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

- 递归写法
- 注意`left > right`因为有可能是最后缩小到区间只有一个数的时候

``` javascript
var search = function(nums, target) {
    function binarySearch(left, right){
        if(left > right) return -1;
        let mid = parseInt(left + (right - left)/2);
        if(nums[mid] == target) return mid;
        else if(nums[mid] > target) return binarySearch(left, mid -1);
        else if(nums[mid] < target) return binarySearch(mid + 1, right); 
    }
    return binarySearch(0,nums.length - 1)
};
```

- 左侧第一个

``` javascript
function binarySearch(left, right) {
    if (left > right) return -1;
    let mid = parseInt(left + (right - left) / 2);
    if (nums[mid] == target) {
        if (nums[mid - 1] != target) return mid;
        else return binarySearch(left, mid - 1);
    }
    else if (nums[mid] > target) return binarySearch(left, mid - 1);
    else if (nums[mid] < target) return binarySearch(mid + 1, right);
}
```

- 右侧第一个

``` javascript
function binarySearch(left, right) {
    if (left > right) return -1;
    let mid = parseInt(left + (right - left) / 2);
    if (nums[mid] == target) {
        if (nums[mid + 1] != target) return mid;
        else return binarySearch(mid + 1, right);
    }
    else if (nums[mid] > target) return binarySearch(left, mid - 1);
    else if (nums[mid] < target) return binarySearch(mid + 1, right);
}
let nums = [-1, 9, 9, 9, 9, 12], target = 9;
console.log(binarySearch(0, nums.length - 1));
```

## [875. 爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas/)★

- 速度是有理论区间范围的，最大速度是最大的那一堆，能保证一小时肯定吃完一堆，比这个更大没有意义。最小速度是堆的总和/规定时间，比这个还小的话一定吃不完(在这里`不能取最小的那一堆`，是可以比这个更小的，当数组只有一个数的时候会出问题)。`注意理论和实际的区别`，`实际上是根据速度一堆一堆的吃，并不能保证每天都能刚好吃够平均每天应该吃的量`
- 实际吃完的时间就是f，target就是规定时间。下面的写法思路是一样的，`每一堆吃完的时间=每一堆的香蕉数/自变量，累加每一堆的时间。一旦H>h，跳出循环`。
- `H>h`，说明速度不够大，所以调整`left，left=mid+1；`
- 而如果跳出循环是因为`H<h就已经吃完了`，得`确定是不是最小的速度`，所以判断一下`mid-1能否吃完`。能吃完，说明`最小速度还在左边，right = mid -1` ；如果`不能吃完，return mid`。这个mid就是所求。
- 本质就是在`暴力法的基础上，运用二分查找剪枝提高效率`。

``` javascript
var minEatingSpeed = function(piles, h) {
    function eatAll(k){
        // 每一堆都要在h小时内吃完才可以
        let H = 0;
        // 要吃完最后一堆
        for(let i = 0; i < piles.length; i++){
            H += Math.ceil(piles[i] / k);
            if(H > h) break;
        }
        // 判断是吃完了最后一堆结束循环，还是没有吃完但已经到了H小时结束循环
        if(H > h) return false;
        else return true;
    }
    // 最大速度是堆数的和/小时
    // 最小速度是数量最小的那一堆，如果比这个还小，则肯定不能吃完。
    let sum  = 0;
    for(let i = 0; i < piles.length; i++) sum += piles[i];
    let min = Math.ceil(sum / h);
    let max = Math.max(...piles);
    while(min  <= max){
        mid = parseInt(min + ( max - min ) / 2);
        // 判断如果每小时吃K根，能否吃完
        if(eatAll(mid)){
            // 能吃完，找左边界
            // 如果-1还能吃完继续找左边界；如果不能吃完，说明这个就是最小值
            if(eatAll(mid-1)) max = mid - 1;
            else return mid;
        } else {
            // 不能吃完，说明速度小了，往右边找
            min = mid + 1;
        }
    }
};
```

## [1011. 在 D 天内送达包裹的能力](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/)

- `自变量`就是`船的运载能力`，`最小值是最重的包裹`，保证这个包裹可以被运送，比这个小，这一个包裹都没法运输；`最大值`是所有`包裹的重量和`，第一天就运送完所有包裹
- `运输的天数`与`船的运载能力`成`反比`。暴力方法就是从最小值开始尝试到最大值，一旦有一个在要求的天数内运输完，就是所求。因此联想到用二分搜索优化。
- 在判断船的运载能力能否的达到要求时，特别注意`Day的初始值`。遍历每个货物，如果加入这个货物，未超重，则继续；如果加入这个货物会超重，则当天的货物已经打包完毕，这个货物在第二天运送。当运输的天数>题目给的要求时，跳出循环。然后判断是因为在days天内就运输完毕所有货物跳出循环，还是因为超过days天还没运送完毕，跳出循环。
- 根据判断得到的结果，调整区间，寻找边界。

``` javascript
var shipWithinDays = function(，weights, days) {
    // 判断载重是否达到要求
    function shipAll(load){
        let Day = 1, cargo = 0; //计算每一天应该运载的包裹重量，注意Day要从1开始而不是0，否则当最后一天只剩最后 一个货物要运输时，会不算入天数。可以自己用一个数组推断一下
        for(let i = 0; i < weights.length; i++){
            if(cargo + weights[i] <= load) {
                cargo += weights[i];
            } else {
                // 货物重量达到了船的最大载重
                cargo = weights[i] //注意这里不能 是0，否则会跳过weight[i]这个货物
                Day++;  //应该是第二天了
            }
            if(Day > days) break; //一旦到了days天还没运送完，说明这个载重没法在days天内运送完
        }
        // 判断是因为在days天内运送完所有货物结束循环，还是因为到了days天还没运送完所有货物结束循环
        if(Day <= days) return true;
        else return false;
    }

    //船的载重有一个区间范围，要在5天内运完所有的货物，要保证最重的包裹也能被运输，所以是最小值是最重的包裹
    // 理论上的最大值是weights的总和，这样能保证一天就送完。
    let sum = 0;
    for(let i = 0; i < weights.length; i++) sum += weights[i];
    let left = Math.max(...weights);
    let right = sum,mid; 
    while(left <= right) {
        mid = parseInt(left + (right - left)/2);
        if(shipAll(mid)){
            // 可以装载完，判断是不是左边界。注意可能刚好是最左边，所以mid-1出问题
            if(mid == Math.max(...weights)|| !shipAll(mid - 1)) return mid;
            else right = mid - 1;
        } else {
            // 装载量不够
            left = mid + 1;
        }
    }
};
```

## [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

- 思路是使用`两次二分查找`，`第一次`用于确定`左边界`，`第二次`用于确定`右边界`
- 考虑到找左边界和右边界的代码有细节的不同。
- 所以我们联想到都使用找左边界的方法，`第一次`找`target的左边界`，`第二次`找`target+1的左边界`。注意如果没找到我们要`return left。`
- 自己代入数组后会发现，比如[6,7,7,9]，target是7，调用binarySearch(target+1)，会发现left停留在3。注意一定是`target + 1`，才能保证找到的是target右边界后面的一个位置

``` javascript
var searchRange = function(nums, target) {
    // 使用两次二分查找，第一次确认左边界，第二次确认右边界
    function binarySearch(target){
        let left = 0, right = nums.length -1;
        // 确认左边界
        while(left <= right){
            let mid = parseInt(left + (right - left)/2);
            if(nums[mid] == target){
                // 判断是不是左边界
                if(nums[mid-1] == target){
                    //前一个数还是target，不是左边界                 
                    right = mid - 1;
                } else {
                    //前一个数不是target，是左边界   
                    return mid;
                }
            } else if(nums[mid] > target){
                // 实际数在左边
                right = mid - 1;
            } else if(nums[mid] < target){
                //实际数在右边
                left = mid + 1;
            }
        }
        return left;
    }
    let leftIndex = binarySearch(target);
    // 左边界就已经不是target
    if(nums[leftIndex] != target) return [-1, -1];
    let rightIndex = binarySearch(target + 1);
    return[leftIndex, rightIndex - 1];
};
```

## [剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

- 根据题意，如果该`长度为n-1的递增排序数组没有缺失数字`(每个数字都在范围0～n-1内)，那么数组就是[0,1,2,3,4]可以看出`每个数的下标索引与它数本身是相等的`。其中`有一个数缺失`后，会`导致之后的数下标索引和数本身不相等`。
- 进行二分搜索时，如果`这个数字的下标索引与值不相等`，要判断`是不是第一个出错`的数，如果`是`，返回`下标索引`；如果`不是`，往`左边区间继续搜索`
- 注意的地方有两点，一：有可能缺失的是第一个 数，因此判断是否是第一个缺失的数 `nums[mid-1]= mid- 1`会出现问题，加上判断条件`mid - 1 < 0`。只有当left 和 right都等于0时，mid才会取0，也就是说只有这个区间出错，并且题目是一定会有缺失，所以只可能是0出错。二：当数组是`[0,1,2]`的时候，`缺失的数字是3`，也就是当`nums.length - 1 == nums[nums.length - 1]`时，要返回nums.length

``` javascript
var missingNumber = function(nums) {
    if(nums.length - 1 == nums[nums.length - 1]) return nums.length;
    // 漏掉的话，就是当前数的索引和数不相等，顺序，递增考虑用二分查找，找第一个不正常的数
    let left = 0, right = nums.length - 1;
    while(left <= right){
        let mid = parseInt(left + (right - left) / 2);
        if(nums[mid] == mid){
            // 如果是正常的，左边一定是正常的。
            left = mid + 1;
        } else {
            // 判断是不是缺失的数，缺失的数，会是第一个index不等于数值的数
            if(mid -1 < 0 || nums[mid - 1] == mid  - 1) return mid;
            else right = mid - 1; //如果上一个数也是index不等于数值得到数，那么第一个出错的数在左边
        }
    }
};
```

## [剑指 Offer 04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)★

### 法一 二分搜索

- 遍历二维数组，对每一个一维数组使用二分搜索
- 时间复杂度O(nlogn)

```` javascript
    for(let i = 0; i < matrix.length; i++){
        let left = 0, right = matrix[i].length - 1;
        while(left <= right){
            let mid = parseInt(left + (right - left)/2);
            if(matrix[i][mid] == target) return true;
            else if(matrix[i][mid] > target) right = mid - 1;
            else if(matrix[i][mid] < target) left = mid + 1;
        }
    }
    return false;
````

### 法二：单调性

- 对于每个子矩阵右上角的数`x`，`x`左边的数都小于等于`x`，`x`下边的数都大于`x`

  ![image-20211217095344738](C:\Users\zayn\AppData\Roaming\Typora\typora-user-images\image-20211217095344738.png)

- 因此，从矩阵 的右上角开始枚举：
  1. 如果`target = x`，说明找到了，`返回x的坐标`
  2. 如果`target > x`，说明当前x所在的`一整行`，都`不符合要求，`所以`x向下`移动
  3. 如果`target < x`，说明当前x所在的`一整列`，都`不符合要求，`所以`x向左`移动

- 时间复杂度：O(m+n)，
- 从左上角开始，对于同一种情况有多种选择；`从右上角开始，一种情况就只有一种选择`

``` javascript
    if(matrix.length == 0) return false;
    let x = 0, y = matrix[0].length - 1;
    while(x < matrix.length && y >= 0){
        if(matrix[x][y] == target) return true;
        else if(matrix[x][y] > target) y--;
        else if(matrix[x][y] < target) x++;
    }
    return false;
```

## [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)★

- 数组具有二段性，`旋转点左边都>=nums[0]`，`旋转点右边都<nums[0]`。可以使用二分

- 如果`nums[mid] == target`，返回下标
- 如果`nums[mid] < target`，要先判断mid在左边还是右边，因为不同的位置，扩大的方式不同。如果当前mid在左边，想要接近target只能右移，所以`left = mid + 1`；而如果当前mid在右边，既可以通过左移，也可也通过右移接近target，因此需要判断target所在的位置(如果target在左边数组，左移`right = mid - 1`；如果target在右边数组，右移`left = mid + 1`);
- 如果`nums[mid] > target`，要先判断mid在左边还是右边，因为不同的位置，缩小的方式不同。如果当前mid在右边，想要接近target只能左移，所以`right = mid - 1`；而如果当前mid在左边，既可以通过左移，也可也通过右移接近target，因此需要判断target所在的位置(如果target在左边数组，左移`right = mid - 1`；如果target在右边数组，右移`left = mid + 1`);
- 判断数在哪一边的方法：将该数与nums[0]比较，如果`大于等于`就在左边数组，如果`小于`就在右边数组
- 时间复杂度O(logn)

``` javascript
var search = function(nums, target) {
    // 遍历一遍，看有没有target O(n)
    // return nums.indexOf(target);

    let left = 0,  right = nums.length - 1;
    while(left <= right){
        let mid = parseInt(left + (right - left) / 2);
        if(nums[mid] == target) return mid;
        else if(nums[mid] < target) {
            // 要增大nums[mid]，首先判断当前mid在哪里
            if(nums[mid] >= nums[0]){
                // 左边数组
                left = mid + 1;
            }else{
                //右边数组，增大，既可以向左移动也可也向右移动.判断target在哪边
                if(target < nums[0]){
                    // target在右边数组
                    left = mid + 1;
                } else {
                    // target在左边数组
                    right = mid - 1;
                }
            }
        }else if(nums[mid] > target){
            // 要缩小nums[mid]，首先判断当前mid在哪里
            if(nums[mid] >= nums[0]){
                // 左边数组，减小既可以往左移动，也可以往右移动
                if(target < nums[0]){
                    // target在右边数组
                    left = mid + 1;
                } else{
                    // target在左边数组
                    right = mid - 1;
                }
            }else {
                // 右边数组，减小左移
                right = mid - 1;
            }
        }
    }
    return -1;
};
```

##  [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

```
输入：nums = [1,3,5]
输出：1

输入：[3,4,5,1,2]
输出：1

输入：[2,2,2,0,1]
输出：0
```

### 法一：遍历数组

- 从头到尾遍历一次数组，找到小于前面一个数的数字，返回该数。如果遍历结束，仍没有找到该数，说明是第一个数字出错，返回numbers[0]
- 时间复杂度：O(n)

``` javascript
    // O(n):遍历一遍,找到第一个比前一个数小的数字
     for(let i = 1; i < numbers.length; i++){
        if(numbers[i] < numbers[i - 1]) return numbers[i]
    }
    return numbers[0];
```

### 法二：二分查找

- 因为数组允许有重复元素，所以`数组的二分性被破坏`。例如对于[1,2,2,2,3,4]来说，以第三个2为中心旋转，旋转后的数组就是[2,3,4,1,2,2]；这样会导致，分界点左边的数组均>=nums[0]，右边的数组均<=nums[0]。那么对于nums[0]来说，它应该分到哪一组就没法确定
- 所以我们先`恢复数组的二分性`，将`右边数组等于nums[0]的数消除`，不用担心会不会导致最小数字被消除掉。因为第一个nums[0]仍然被保留
  - 计算出mid后，`mid = parseInt(left + (right - left)/2)`。判断当前数是否符合要求。如果`nums[mid] < nums[mid - 1]`，那么这个数就是分界点返回；
  - 如果不是，判断当前数在哪边，`nums[mid] >= nums[0]`，当前数在左边，需要右移靠近分界点`left = mid + 1`；`nums[mid]  < nums[0]`，当前数在右边，需要左移靠近分界点，`right = mid - 1`；

``` javascript
var findMin = function(nums) {
    // 最小的数字其实就是那个旋转点
    // 为了维持数组的二分性，将右边等于numbers[0]的数消除
    let left = 0, right = nums.length - 1;
    while(nums[right] == nums[0]) right--;
    while(left <= right){
        let mid = parseInt(left + (right - left)/2);
        if(nums[mid] < nums[mid - 1]) return nums[mid];
        // mid在左边数组，往右移
        else if(nums[mid] >= nums[0]) left = mid + 1;
        // mid在右边数组，往左移
        else if(nums[mid]  < nums[0]) right = mid - 1;
    }
    return nums[0];
};
```

