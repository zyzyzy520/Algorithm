## [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)

``` bash
输入：s = "3[a]2[bc]"
输出："aaabcbc"

输入：s = "gh2[abc]3[cd]ef"
输出："ghabcabccdcdcdef"
```

需要处理外层包含内层的情况时，很容易让人联想到用栈模拟算数运算

- 用一个栈`stackTimes[]`存放每一层倍数，一个栈`stackArr=[]`存放每一层，一个变量`strAll = ''`存放处理好的字符串，一个变量`sum=0`用于计算每一层倍数。
- 遍历s
  - 如果s[i]是`数字`
    - 进行倍数的计算`sum = sum * 10 + parseInt(s[i])`
  - 如果s[i]是`[`
    - 说明`新的一层开始`了，`先将该层的倍数sum压入stackTimes`中，然后`sum=0`(用于下一层的计算)
    - 生成新的空数组代表这一层，压入`stackArr`中
  - 如果s[i]是`字母`
    - 因为有可能当前没有层，是直接裸着的只重复一次的字符，例如`gh2[abc]3[cd]ef`。
    - 所以先判断`stackArr`是否为空
      - **`为空，说明没有层，直接将s[i]接在strAll后面`**
      - **`不为空，将s[i]压入最近的层，stackArr栈顶的数组`**
  - 如果s[i]是`]`
    - 说明`当前层结束了`
    - 弹出**`stackTimes栈顶当前层的重复次数times`**，弹出**`stackArr栈顶数组当前层的所有字符并组成字符串str=stackArr.pop().join('')`**
    - 通过`str.repeat(times)`生成重复后的字符串str。
    - 对于当前层，不确定是不是最外层，所以要进行判断，判断`stackArr`是否为空
      - **`为空`**，说明当前层是**`最外层`**，**`将字符串接在strAll后面`**
      - **`不为空`**，说明当前层是**`里层`**，**`将字符串压入stackArr栈顶最近层中`**

``` javascript
var decodeString = function(s) {
    // 用一个sum来计算数字，一个栈来记录次数，一个栈来记录字符数组
    let sum = 0, stackTimes = [], stackArr = [];
    let strAll = ''
    // 遍历s
    for(let i = 0; i < s.length; i++){
        // [:将要重复的字符次数和对应的字符数组压入栈中，将sum清0，计算下一个
        if(s[i] == '['){
            stackTimes.push(sum), sum = 0;
            let arr = new Array();
            stackArr.push(arr);
        }else if(s[i] == ']'){
            // 拿出字符，和字符需要重复的次数
            let times = stackTimes.pop();
            let str = stackArr.pop().join('');
            str = str.repeat(times); 
            // 判断字符栈是否为空
            if(stackArr.length == 0){
                // 说明没有内嵌的字符串了，直接全局加
                strAll += str
            } else {
                // 有内嵌的字符串
                stackArr[stackArr.length - 1].push(str);
            }
        } else if( s[i] >= 'a' && s[i] <= 'z'){
            // 针对ef这种只有一次的情况，判断字符数组栈是否为空
            if(stackArr.length == 0){
                // 为空，说明没有嵌套，直接加
                strAll += s[i]
            } else {
                // 有嵌套，压入栈顶
                // 字母，压入字符数组栈顶的数组
                stackArr[stackArr.length - 1].push(s[i]);
            }
        } else {
            // 数字，计算次数
            sum = sum*10 + parseInt(s[i]);
        }
    }
    return strAll;
};
```

