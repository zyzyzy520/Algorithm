## [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

- 

``` javascript
var reverseList = function(head) {
    // if(head == null || head.next == null) return head;
    // let pre = null, cur = head, next =cur.next;
    // while(next != null){
    //     cur .next = pre;
    //     pre = cur;
    //     cur = next;
    //     next = next.next;
    // }
    // cur.next = pre;
    // head.next = null;
    // return cur;
    let ans;
    function reverse(node){
        // node == null用于判断输入是空节点的情况
        if(node == null || node.next == null){
            ans = node;
            return;
        }
        // 拆解成更小的问题
         reverse(node.next);
        // 将得到的子问题的解进行组合
        node.next.next = node;
        node.next = null;
    }
    reverse(head);
    return ans;
};
```



## [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

- 两个链表都是升序的，所以`比较l1和l2指针的值`，`最小的就是合并后新链表最小的值`。
- 给新链表设置`哨兵指针`，方便加入新结点。
- 跳出循环时，两个链表中，如果`有一个不为空`，直接整体接到新链表后面即可，不需要遍历一个一个接，即`tail.next = l1|l2`

``` javascript
var mergeTwoLists = function(l1, l2) {
    // 新升序列表的头结点
    let head = new ListNode();
    let tail = head;

    while(l1 != null && l2 != null){
        if(l1.val < l2.val){
            tail.next = l1;
            l1 = l1.next;
        }else {
            tail.next = l2;
            l2 = l2.next;
        }
        tail = tail.next;
    }

    // 不需要挨个接，直接整体接上即可。
    if( l1 != null){
        tail.next = l1;
    }
    if(l2 != null) {
        tail.next = l2;
    }

    return head.next;
};
```

## [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

### 朴素方法：`顺序合并`

- 按顺序，从第一个开始，遍历数组，顺序合并

``` javascript
var mergeKLists = function(lists) {
    function merge (l1, l2){
        let head = new ListNode();
        let tail = head;
        // 将11和l2合并后，返回头结点。
        while(l1 != null && l2 != null) {
            if(l1.val < l2.val){
                tail.next = l1;
                l1 = l1.next;
            }else {
                tail.next = l2;
                l2 = l2.next;
            }
            tail = tail.next;
        }
        if(l1 != null){
            tail.next = l1;
        }
        if(l2 != null){
            tail.next = l2;
        }
        return head.next;
    }
    if(lists.length == 0) return null;
    let l1  = lists.pop(), l2;
    // 两个两个之间合并
    while(lists.length > 0){
        l2 = lists.pop();
        l1 = merge(l1,l2);
    }
    return l1;
};
```

### 分治

``` javascript
var mergeKLists = function(lists) {

    function merge (l1, l2){
        let head = new ListNode();
        let tail = head;
        // 将11和l2合并后，返回头结点。
        while(l1 != null && l2 != null) {
            if(l1.val < l2.val){
                tail.next = l1;
                l1 = l1.next;
            }else {
                tail.next = l2;
                l2 = l2.next;
            }
            tail = tail.next;
        }
        if(l1 != null){
            tail.next = l1;
        }
        if(l2 != null){
            tail.next = l2;
        }
        return head.next;
    }
    function include(lists, left, right){
        if(left >= right) return lists[left];

        // 分
        let center = parseInt((left + right)/2);
        let subset1 = include(lists, left, center);
        let subset2 = include(lists, center + 1, right);

        // 治
        let total = merge(subset1, subset2);
        return total;
    }
    if(lists.length == 0) return null;
    return include(lists, 0, lists.length - 1);
};
```

## [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

- 注意，是`删除倒数第N个`结点，那么我们需要找到的是`倒数第N+1个`结点。
- 双指针：`left，right，距离为N+1`，当`right走到null`时，`left就是倒数第N+1`个结点。再`left.next = left.next.next`即可删除
- 注意使用`虚拟头结点`的技巧，也是为了防止出现空指针的情况，比如说`链表总共有 5 个节点`，题目就让你`删除倒数第 5 个节点`，也就是`第一个节点`，那按照算法逻辑，应该`首先找到倒数第 6 个节点`。但`第一个节点前面已经没有节点了，这就会出错`。但有了虚拟节点`dummy`的存在，就避免了这个问题，能够对这种情况进行正确的删除
- 倒数第K个，不会因为在头部加了虚拟结点改变，但会因为 在尾部加节点出错
- `left和right一开始都是指向dummy`
- 注意是`return dummy.next`。当删除的不是第一个结点的时候，return head和return dummy.next效果是一样的；但如果是删除第一个结点，head结点已经被删除了，此时是return dummy.next。所以应当是`return dummy.next`

``` javascript
var removeNthFromEnd = function(head, n) {
    // 删除第n个结点，需要得到倒数第n+1个结点
    // 设立哨兵结点，处理删除倒数第5个结点，即第一个结点的情况
    let dummy = new ListNode(0,head);
    let left = dummy, right = dummy;
    for(let i = 1; i <= n + 1; i++){
        right = right.next;
    }
    while(right != null){
        left = left.next;
        right = right.next;
    }
    left.next = left.next.next;

    return dummy.next;
};
```

## [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

- 两个指针`slow`和`fast`分别指向链表头结点`head`。**每当慢指针`slow`前进一步，快指针`fast`就前进两步，这样，当`fast`走到链表末尾时，`slow`就指向了链表中点**。

- 有两种情况：结点数目是`奇数`和结点数目是`偶数`。
- `奇数`时，fast走到`最后一个结点`，满足 要求
- `偶数`时，fast走到`null`，满足要求
- 可以画图测试一下。

``` javascript
var middleNode = function(head) {
    let slow = head, quick = head;
    // 有一个满足就说明找到中间结点，跳出
    while(quick != null && quick.next != null){
        slow = slow.next;
        quick = quick.next.next;
    }
    return slow;
};
```

     ## [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

- 每当慢指针`slow`前进一步，快指针`fast`就前进两步。如果`fast`最终遇到空指针，说明链表中没有环；如果`fast`最终和`slow`相遇，那肯定是`fast`超过了`slow`一圈，说明链表中含有环
- 当`fast.next = null(奇数`个结点)，或者`fast = null(偶数`个结点)时，说明没有环。

``` javascript
var hasCycle = function(head) {
    let slow = head, fast = head;
    // 注意判断顺序不要错，可以想一下特殊情况，哪个限制要放在前面。
    while(fast!= null && fast.next  != null){
        fast = fast.next.next;
        slow = slow.next;
        if(slow == fast) return true;
    }
    //走到结尾，没有环
    return false;
}
```

## [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

- 从头结点开始，`slow指针走一步`，`fast指针走两步`。如果`fast=null(偶数`个结点)或者`fast.next=null(奇数`个结点)都还没有相遇，说明没有环。
- `相遇时`，假设`slow`走了`k`步，那么`fast`走了`2k`步。`head走k步可以到相遇点`，从`相遇点走k步可以到相遇点`。`起点距离相遇点m步`，那么`从head走k-m步可以到起点`，`从相遇点走k-m步可以到起点`。
- 所以当slow和fast相遇时，将slow放到head，然后slow和fast同时一步一步走，直到相遇，这个相遇的 点就是环的起点。

``` javascript
var detectCycle = function(head) {
    let slow = head, quick = head;
    // 首先找到相遇的结点
    while(quick != null && quick.next != null) {
        slow = slow.next;
        quick = quick.next.next;
        if(slow == quick){
            // 有环
            slow = head;
            while(slow != quick){
                slow = slow.next;
                quick = quick.next;
            }
            return slow;
        }
    }
    // 走到尾结点，说明无环
    return null;
};
```

## [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

- A遍历完headA，移动到headB；B遍历完headB，移动到headA。两者相遇即是交点
- 注意事项：`要一步一步走`。`将A移动到headB算一步，然后往后走算一步`。如果把A = A.next放在if外面，会导致节点移动到headB，立马又向后走了一步，如果相交的是头结点，就得不到答案

``` javascript
var getIntersectionNode = function(headA, headB) {
    let A = headA, B = headB;
     while(A != B){
         if(A == null){
            A = headB;
         } else {
            A = A.next; 
         }
         if(B == null){
            B = headA;
         } else {
            B = B.next;
         }
     }
     return  A;
};
```

## [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

- 栈的特点是后进先出，即最后压入栈的元素最先弹出。考虑到栈的这一特点，使用栈将链表元素顺序倒置。`从链表的头节点开始，依次将每个节点压入栈内，然后依次弹出栈内的元素并存储到数组中`。

``` javascript
var reversePrint = function(head) {
    const  result = new Array()
    while(head != null) {
        result.unshift(head.val);
        head = head.next;
    }
    return result;
};
```

``` javascript
var reversePrint = function(head) {
    const result1 = new Array();
    const result2 = new Array();
    // 遍历，将链表的值顺序压入栈1中
    while(head != null) {
        result1.push(head.val);
        head = head.next;
    }
    // 将栈1弹出的数压入栈2中实现倒置
    while(result1.length != 0){
        result2.push(result1.pop());
    }
    return result2;
};  
```

## [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

- 迭代写法

- 注意`结束条件是next到null`，如果终止条件是cur到null的话，在next到null的时候，三个指针都还需要向后移动一个，next无法在移动了

  

``` javascript
var reverseList = function(head) {
    if(head == null || head.next == null) return head;
    let pre = null, cur = head, next =cur.next;
    while(next  != null){
        cur.next = pre;
        pre = cur;
        cur = next;
        next = next.next;
    }
    cur.next = pre;
    head.next = null;
    return cur;
};
```

- 递归写法
- 当`递归到尾结点时，开始回溯`，注意这里要`记录尾结点`，因为最后要返回反转后的头结点。
- 因为我们没有记录结点的上一个结点，因此要反转得在上一层反转，如果在null时才回溯，是没有办法进行反转的，因为null不需要反转。所以在`尾结点时终止递归进行回溯，在上一层进行反转`。

``` javascript
var reverseList = function(head) {                  
    function reverse(node){
        //终止递归
        if(node.next == null) {
            // 记录一下方便返回头结点
            tail = node;
            return node;
        }
        reverse(node.next);
        node.next.next = node;
    }
    if(head == null) return head;
    reverse(head);
    head.next = null;
    return tail;
};
```

## [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)★

- 复制链表的操作比较好实现，无论是迭代（prev记录上一个结点）还是递归。关键是如何实现随机指针的复制。
- 先顺序复制链表，因为随机指针指向的结点不知道会在什么时候创建，所以先顺序复制链表，用迭代要记录上一个结点、。
- 完成顺序复制后，联想如何复制随即指针。
- 想到`在复制结点的过程中，给结点设置一个新的属性，将复制后的结点绑定给原来的结点`，这样既可以 通过`node.copy`得到复制的结点，也可也通过`node.random.copy`得到随即指针的复制结点，从而可以完成复制。`node.copy.random = node.random.copy`

``` javascript
var copyRandomList = function(head) {
    // 先复制完整的链表
    function copyNode(node){
        if(node == null) return node;
        let  newNode = new Node(node.val,null,null);
        newNode.next = copyNode(node.next);
        node.copy = newNode; //将复制的结点绑定给原来的结点
        // 返回给上一级
        return newNode;
    }
    let newHead = copyNode(head);

    // 再复制随机指针
    let tail = head, newTail = newHead;
    
    while(tail != null){
        if(tail.random == null){
            tail.copy.random = null;
        }else{
            tail.copy.random = tail.random.copy;
        }
        tail = tail.next;
    }
    return newHead;
};
```

## [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

- 遍历链表，找到值和给定的val相等的结点，但注意因为是要删除该节点，所以实际上应该是找上一个节点，我们的判断应该是`tail.next.val == val?`
- 注意`想要删除的节点有可能是头结点`，所以要是`设立哨兵节点`，然后从`哨兵节点.next.val == val?开始循环`找到要删除链表的上一个结点；同时`返回值`也要是`哨兵.next`。因为`头节点可能会被删除`

``` javascript
var deleteNode = function(head, val) {
    // 因为有可能需要删除头结点，所以设立哨兵节点
    let node = new ListNode();
    node.next = head, tail = node;
    while(tail.next.val != val){
        tail = tail.next;
    }
    tail.next = tail.next.next;
    return node.next;
};
```

## [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

- 快慢指针，`快指针先走k步`，`然后快慢指针同时一步一步走`，当`快指针走到null`时，`慢指针指向的节点即是答案`
- 注意删除头结点的情况，推理后发现不需要修改，不需要加入哨兵结点

``` javascript
var getKthFromEnd = function(head, k) {
    let slow = head, quick = head;
    for(let i = 1; i <= k; i++) quick=quick.next;
    while(quick != null){
        slow = slow.next;
        quick = quick.next;
    }
    return slow;
};
```



## [剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

``` bash
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

- `两个指针l1,l2`用于遍历两个排好序的链表。因为两个链表都是排好序的，那么`将l1与l2指向的结点进行比较`，较小的那个一定是目前未排好序中最小的结点。
- 用一个`哨兵结点head`来比较`容易的返回`排好序的链表，`维护一个tail指针`。在l1和l2都没有指向空结点之前，调整tail.next指向l1和l2中小的那个，接着将较小的那一个和tail指针都后移一位

- `循环结束的时候，说明l1和l2至少有一个是空的`，所以判断l1和l2是否为空，将不空的指针直接接到tail.next。

``` javascript
var mergeTwoLists = function(l1, l2) {
    // 新升序列表的头结点
    let head = new ListNode();
    let tail = head;

    while(l1 != null && l2 != null){
        if(l1.val < l2.val){
            tail.next = l1;
            l1 = l1.next;
        }else {
            tail.next = l2;
            l2 = l2.next;
        }
        tail = tail.next;
    }

    // 不需要挨个接，直接整体接上即可。
    if( l1 != null){
        tail.next = l1;
    }
    if(l2 != null) {
        tail.next = l2;
    }

    return head.next;
};
```

## [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

- 注意`节点向后走`与`节点到null后移动到另外一条链表的头结点`都算是节点移动了一步，`不能同时进行`

``` javascript
var getIntersectionNode = function(headA, headB) {
    let a = headA, b = headB;
    // 最终会在交点相遇，如果没有交点，也会在 null处相遇
    while(a != b){
        if(a == null) a= headB;
        else a = a.next;
        if(b == null) b = headA;
        else b = b.next
    }
    return a;
};
```

